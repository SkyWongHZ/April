# 为什么选择直接使用 Sentry SDK，而不是自己封装的包

## 这个改变是基于以下几个因素：

1. **构建问题**：我们在尝试构建 `packages/monitoring` 时遇到了一些类型错误，这些问题在短时间内难以完全解决。

2. **简化性**：基于"最小产品"的原则，直接使用 Sentry SDK 更加简单明了，减少了中间层。

3. **一致性**：虽然不使用自己封装的文件，但实现的思路完全符合我们之前讨论的精简版监控系统的设计理念：
   - 降低采样率 (0.1)，节省 Sentry 免费配额
   - 专注于核心功能：错误捕获和基本性能监控
   - 忽略不重要的错误

## 现在的实现

当前的 `MonitoringClientWrapper.tsx` 实现：

1. 直接导入并使用 `@sentry/react` 和 `@sentry/tracing`
2. 自定义了一个精简的 `ErrorBoundary` 组件
3. 在 `useEffect` 钩子中初始化 Sentry
4. 设置低采样率 (0.1)，适合 Sentry 免费方案
5. 添加了错误过滤和标签

这个实现本质上完成了与我们设计的精简版监控系统相同的功能，只是不通过中间层，而是直接使用 Sentry SDK。

## 您可以选择的方案

如果您希望保持项目结构的一致性，您有以下选择：

1. **保持当前方案**：直接在 `MonitoringClientWrapper.tsx` 中使用 Sentry SDK，这种方式简单、直接、可靠。

2. **迁移到封装包**：修复 `packages/monitoring` 中的构建问题，然后更新 `MonitoringClientWrapper.tsx` 以使用自己封装的包。这需要更多工作，但会保持项目结构一致性。

3. **混合方案**：保留当前的实现，但仅将 `@monitoring/monitoring` 中的一些实用工具函数引入进来，而不依赖它的整体结构。

## 建议

基于"最小产品"的原则，我建议保持当前方案。这样可以：

- 确保监控功能正常工作
- 避免复杂的构建问题
- 直接受益于 Sentry 官方 SDK 的更新
- 减少维护负担

在未来，当项目更加成熟或有特殊需求时，再考虑迁移到自己封装的包。 